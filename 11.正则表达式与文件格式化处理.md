举例来说，在你日常使用vim做文字处理或程序编写时使用到的“搜索/替换”等功能，这些动作要做的漂亮，就得要配合正则表达式来处理。



简单的说，正则表达式就是处理字符串的方法，他是以行为单位来进行字符串的处理行为，正则表达式通过一些特殊符号的辅助，可以让使用者轻易达到“搜索/删除/替换”某特定字符串的处理程序

grep 'mail' /lib/systemd/system/*

正则表达式是一种表示法，只要工具程序支持这种表示法，那么该工具程序就可以用来作为正则表达式的字符串处理之用。例如vi, grep, awk, sed 等工具，因为他们有支持正则表达式，所以，这些工具就可以使用正则表达式的特殊字符来进行字符串的处理。但例如cp, ls等指令并未支持正则表达式，所以就只能使用_bash自己本身的通配符_而已

正则表达式的字符串表示方式按照不同的严谨度分为：基础正则表达式和扩展正则表达式。

扩展正则表达式除了简单的一组字符串处理之外，还可以做群组的字符串处理，例如进行搜索VBird或netman或lman的搜索，藉由特殊的( 与 |等字符的协助，就能够达到这样的目的。

>正则表达式和通配符是完全不一样的东西。因为通配符代表的是bash里面的一个功能，但是正则表示的的是一种字符串处理的表示方式

对字符排序有影响的语系资料就会对正则的结果有影响。使用正则表达式时，要特别留意当时环境的语系为何，否则可能会发现与别人不相同的截取结果

### 11.2.2 grep的一些高级选项

```shell
$ grep [-A] [-B] [--color=auto] '搜索字符串' filename
选项与参数：
-A：后面可加数字，为after的意思，除了列出该行歪，后续的n行也列出来
-B：后面可加数字，为before的意思，除了列出该行外，前面的n行也列出来
--color=auto 可将正确的那个截取数据列出颜色
```

> 范例一：用dmesg 列出核心信息，再以grep 找出内含qxl 那行

```shell
$ dmesg | grep 'qxl'
```

> 范例三：在关键字所在行的前两行与后三行也一起显示出来

```shell
$ dmesg | grep -A 3 -B 2 -n "qxl"
```

grep 是一个很常见也很常用的指令，最重要的功能就是进行字符串数据的比对，然后将符合使用者需求的字符串打印出来。grep在资料中查询一个字符串时，是以“整行”为单位来进行数据的截取的。

----

#### 11.2.3 基础正则表示法练习

語系已經使用 export LANG=C; export LC_ALL=C 的设定值

例题一：搜索指定字符串：

```shell
$ grep -n 'the' regular_express.txt
```

要取得不论大小写的the：

```shell
$ grep -in 'the' regular_express.txt
```

例题二：利用中括号[]来搜索集合字符

如果我想要搜索test 或者 taste ,可以这样写

```shell
$ grep 't[ae]st' regular_express.txt
```

[]里面不论有几个字符，他都仅代表一个字符

想要搜索oo前面不带g的：

```shell
$ grep '[^g]oo' regular_express.txt
```

不想要oo前面带小写字符的：

```shell
$ grep '[^a-z]oo' regular_express.txt
```

如果该字符组是连续的，例如大写英文/小写英文/数字等，就可以使用[a-z],[A-Z],[0-9]等方式来书写，如果要求字符串是数字与英文，就将他们全部写在一起，变成[a-zA-Z0-9]

由于考虑到语系对于编码顺序的影响，因此除了连续编码使用-号外，也可以使用如下方法：

```shell
$ grep -n '[^[:lower:]]oo' regular_expresss.txt
$ grep -n '[[:digit:]]' regular_express.txt 
```

例题三：行首与行尾字符^$

如果我想要让the只在行首列出，这个时候就要使用定位字符了：

```shell
$ grep -n '^the' regular_express.txt
```

如果想要开头是小写字符的

```shell
$ grep -n '^[a-z]' regular_express.txt
```

或者

```shell
$ grep -n '^[[:lower:]]' regular_express.txt
```

:star: 如果不想要开头是英文字母：

```shell
$ grep -n '^[^a-zA-Z]' regular_express.txt
or
$ grep -n '^[^[:alpha:]]' regular_express.txt
```

__^在字符集合符号之内外是不同的，在[]内代表反向选择，在[]之外则代表定位在行首的意义__

如果我想要找出来，行为结束为小数点（.）的那一行，应该：

```shell
$ grep -n '\.$' regular_express.txt
```

cat -An regular_express.txt | head -n 10 | tail -n 6

如果想要找出来，哪一行是空白行，也就是说，该行并没有输入任何数据，应该

```shell
$ grep -n '^$' regular_express.txt
```

省掉空白行和注释应该怎么做：

```shell
$ grep -vn '^$' /etc/rsyslog.conf | grep -vn '^#'
```

##### 例题四：任意一个字符.与重复字符*

通配符*可以用来代表任意（0或多个）字符，但是正则表达式并不是通配符，正则表达式中的. 代表“绝对有一个任意字符”

__.（小数点）：代表一定有一个任意字符的意思__

__*（星星号）：代表重复前一个字符，0到无穷多次的意思__

如果我想要字符串开头结尾都是g，但是两个g之间仅能存在至少一个o，那应该：

```shell
$ grep -n  'goo*g' regular_express.txt
```

如果想要找出[任意数字]的行列，因为仅有数字，所以

```shell
$ grep -n '[0-9][0-9]*' regualr_express.txt
```

例题五：限定连续RE 字符范围{}

限制范围的字符{}。但因为{}在shell是有特殊意义的，因此，我们必须要使用跳转字符来让他市区特殊意义。

假设我要找到两个o的字符串：

```shell
$ grep -n 'o\{2\}' regular_express.txt
```

:star: 如果我们要找出g后面接2到5个o，然后再接一个g字符串，应该是：

```shell
$ grep -n 'go\{2,5\}g' regular_express.txt
```

想要两个o以上的：

```shell
$ grep -n 'go\{2,\}g' regular_express.txt
```

----

##### 11.2.4 基础正则表达式字符汇整

|   RE字符    | 意义与范例                                    |
| :-------: | ---------------------------------------- |
|   ^word   | <u>意义：待搜索的字符串在行首</u> 范例：搜索行首为# 开始的那一行，并列出行号：grep -n '^#' filename |
|   word$   | <u>意义：待搜索的字符串在行尾</u> 范例：将行尾为! 的那一行打印出来，并打印出行号：grep -n '!$' filename |
|     .     | <u>意义：代表“一定有一个任意字符”的字符</u> 范例：搜索的字符串可以是(eve)(eae)(eee)(e e)但不能仅有(ee),亦即e与e中间一定仅有一个字符，而空白字符也是字符：grep -n 'e.e' filename |
|     \     | <u>意义：跳转字符，将特殊符号的特殊意义去除</u> 范例：搜索含有单引号‘ 的那一行：grep -n \' filename |
|     *     | <u>意义：重复零个到无穷多个的前一个RE字符</u> 范例：找出含有（es）（ess）（esss）等等的字符串，注意，因为*可以是0个，所以es也是符合带搜索字符串。另外，因为\*重复前一个RE字符的符号，因此在\*之前必须要紧接着一个RE字符，例如任意字符则为.\*  grep -n 'ess\*' filename |
|  [list]   | <u>意义：字符集合的RE字符，里面列出想要截取的字符</u> 范例：搜索含有（gl）或（gd）的那一行，需要特别留意的是，在[]当中“仅代表一个待搜索的字符“，例如”a[afl]y代表搜索的的字符串可以是aay,afy,aly   grep -n 'g[ld]' filename |
|  [n1-n2]  | <u>意义：字符集合的RE字符，里面列出想要截取的字符范围</u>  范例：搜索含有任意数字的那一行，需要特别留意，在字符集合[]中的 -  是有特殊意义的，他代表两个字符之间的所有连续字符，但这个连续与否与ASCII编码有关，因此，你的编码需要设定正确（在bash中，需要确定LANG与LANGUAGE的变量是否正确），例如，所有大写字符为[A-Z]  grep -n '\[0-9][0-9]*' filename |
|  [^list]  | <u>意义：字符集合的RE字符，里面列出不要的字符串或范围</u> 范例：搜索的字符串可以是（oog）（ood）但不能是（oot），那个^在[]内时，代表的意义是反向选择的意思。例如，我不要大写字符，则为\[^A-Z]。但是，需要特别注意的是，如果以grep -n \[^A-Z] filename来搜索，却发现该文件内所有行都被列出，为什么，因为这个\[^A-Z]是非大写字符的意思，因为每一行都有非大写字符，所以就都被列出来了。grep -n 'oo\[gd]\[^t]' filename |
| \\{n,m\\} | <u>意义：连续n到m个的“前一个RE字符”</u> <u>意义：若为\\{n\\},则是连续n个前一个RE字符</u> <u>意义：如果是\\{n,\\},则是连续n个以上的前一个RE字符</u> 范例：在g与g之间有2个到3个的o存在字串，亦即（goog）（gooog） grep -n 'go\\{2,3\\}g' filename |

再次强调，正则表达式的特殊字符与一般在命令行输入在的通配符并不相同，例如，在通配符中*代表的是0~无穷多个字符的意思，但是在正则表达式中\*是重复0到无穷多个前一个RE字符

ls | grep -n  ''   

例题：以ls -l配合grep找出/etc底下文件类型为链接文件属性的文件名：

```shell
$ ls -l /etc | grep -n '^l'
```

#### 11.3 扩展正则表示法

我们要去除空白行以及行首为#的列：cat filename | grep -v '^$' | grep -v '^#'

需要使用管道命令来搜索两次，如果用扩展的正则表达式，我们可以简化为：

```shell
$ egrep -v '^$|^#' regular_express.txt
```

扩展型正则表达式可以通过群组功能| 来进行一次搜索。那个|意为or。

### 11.2.5 sed 工具：行的新增/删除，行的取代/显示, 搜索并取代，直接修改文件

sed 本身也是一个管道命令，可以分析standard input，而且sed 还可以将数据进行替换、删除、新增、截取等特定功能。

```shell
[dmtsai@study ~]$ sed [-nefr] [动作]
# 选项与参数：
# -n：使用安静（silent）模式。在一般sed的用法中，所有来自STDIN的数据一般都会被打印到屏幕上。但如果加上-n参数后，则只有经过sed
#     特殊处理的那一行（或动作）才会被列出来
# -e：直接在指令列模式上进行sed的动作编辑
# -f：直接将sed 的动作写进一个文件内，-f filename 则可以执行filename 内的sed 动作
# -r：sed 的操作支持是扩展型正则表达式的语法（默认是基础正则表达式语法）
# -i：
```



### 11.4.2 awk：好用的数据处理工具

相比于sed 常常用于一个整行的处理，awk则比较倾向于一行当中分成数个列来处理。因此，awk相当适合处理小型的数据。awk通常运行的模式是：

```shell
[dmtsai@study ~]$ awk '条件类型1{动作1} 条件类型2{动作2} ...' filename
```

awk 后面接两个单引号并加上大括号{}来设置想要对数据进行的处理动作。awk可以处理后续接的文件，也可以读取来自前个指令的standard output。但如前所述，<u>awk主要是处理每一行的列内的数据，而默认的列分隔符为空格键或tab键。</u>

举例来说，我们用last可以将登陆者的信息取出来，如果我想要取出账号和登录者的IP，且账号和IP之间以【tab】隔开，就是：

```shell
$ last -n 5 | awk '{print $1 "\t" $3}'
```

以上是awk最常使用的动作，通过print的功能将列数据打印出来。列的分隔则以空格或tab来隔开。因为无论哪一行都要处理，因此就不需要有“条件类型”的限制。

使用awk的时候，请先确认一下你的数据中，如果是连续性的数据，请不要有空格或tab在内，否则会发生误判

在awk的括号内，每一行的每一列都是有变量名称的，那就是\$1,\$2…等变量名称。\$0代表一整行数据的意思。

awk的处理流程是：

1. 读入第一行，并将第一行的

















