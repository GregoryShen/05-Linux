### 8.3 打包指令：tar

----

虽然gzip，bzip2，xz也能够针对目录来进行压缩，不过，这两个指令对目录的压缩指的是“将目录内的所有文件”分别“进行压缩”的动作，而不像在Windows的系统，可以使用类似WinRAR这一类的压缩软件来将好多文件包成一个文件的样式。

这种将多个文件或目录打包成一个大文件的指令功能，我们可以称呼他是一种“打包指令”。

tar可以将多个目录或文件打包成一个大文件，同时还可以通过`gzip`/`bip2`/`xz`的支持，将该文件同时进行压缩。

目前，Windows的WinRAR 也支持`.tar.gz`文件名的解压缩

#### 8.3.1 tar

```shell
$ tar [-z|-j|-J] [cv] [-f 待建立的新文件名] filename... <== 打包与压缩
$ tar [-z|-j|-J] [tv] [-f 既有的 tar文件名]            <== 查看文件名
$ tar [-z|-j|-J] [xv] [-f 既有的 tar文件名] [-C 目录]   <== 解压缩
```

> 选项与参数：
>
> -c    ：建立打包文件，可搭配 `-v`来查看过程中被打包的文件名
>
> -t     ：查看打包文件的内容含有哪些文件名，重点在查看“文件名”就是了
>
> -x     ：解打包或解压缩的功能，可以搭配`-C`在特定目录解开
>
> ​         特别留意的是， `-c`, `-t`, `-x` 不可同时出现在一串指令列中
>
> -z     ：通过 `gzip` 的支持进行压缩/解压缩：此时文件名最好为 `*.tar.gz`
>
> -j      ：通过 `bzip2`的支持进行压缩/解压缩: 此时文件名最好为`*.tar.bz2`
>
> -J     ：通过 `xz` 的支持进行压缩/解压缩：此时文件名最好为`*.tar.xz`
>
> ​         特别留意的是，`-z`，`-j`，`-J` 不可以同时出现在一串指令列中
>
> -v     ：在压缩/解压缩的过程中，将正在处理的文件名显示出来
>
> -f fiiename：-f 后面要立刻接被处理的文件名，建议 `-f`单独写一个选项
>
> -C 目录  ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项
>
>  
>
> 其他后续练习会使用到的选项介绍：
>
> -p（小写）：保留备份文件的原本权限与属性，常用于备份（`-c`）重要的配置文件
>
> -P（大写）：保留绝对路径，亦即允许备份文件中含有根目录存在之意
>
> --exclude=FILE：在压缩的过程中，不要将 FILE 打包

最简单的使用tar 就只要记住底下的方式即可：

* 压缩： `tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称`
* 查询： `tar -jtv -f filename.tar.bz2`
* 解压：`tar -jcv -f filename.tar.bz2 -C 想要解压缩的目录`

`filename.tar.bz2`是我们自己取的文件名，tar 并不会主动产生建立的文件名，所以文件名后缀就很重要了

如果不加`-z|-j|-J`的话，文件名最好取名为`*.tar`即可。

如果是`-j`选项，代表有`bzip2`的支持，因为文件名最好为`*.tar.bz2`,因为`bzip2`会产生`.bz2`的文件名后缀

如果是`-z`选项，那么文件名最好取名为`*.tar.gz`

##### 使用 tar 加入-z, -j 或 -J的参数备份 /etc/ 目录

```shell
$ su - # 因为备份 /etc 需要root 的权限，否则会出现一堆错误
#time tar -zpcv -f /root/etc.tar.gz /etc
tar:Removing leading '/' from member names <==注意这个警告信息
/etc/
...

real 0m0.799s # 多了 time 会显示程序运行的时间，看real就好了
user 0m0.767s
sys  0m0.046s

# 由于加上-v 选项，因此正在处理中的文件名就会显示在屏幕上
# 如果你可以翻到第一页，会发现出现在上面的错误信息
# 至于-p 选项，重点在于“保留原本文件的权限与属性”

#time tar -jpcv -f /root/etc.tar.bz2 /etc
...
#time tar -Jpcv -f /root/etc/tar.xz /etc
...
# 显示的信息会跟上面的一样，不过时间会花的比较多，使用-J时，会花更多的时间

#ll /root/etc*
-rw-r--r--. 1 root root 6721809 Jul  1 00:16 /root/etc.tar.bz2
-rw-r--r--. 1 root root 7758826 Jul  1 00:14 /root/etc.tar.gz
-rw-r--r--. 1 root root 5511500 Jul  1 00:16 /root/etc.tar.xz

# 从上面的结果可以看出，压缩的越快，打包文件越大

[root@study ~]#du -sm /etc
28    /etc     #实际目录约占有28MB的意思
```

压缩比越好当然花费的运算时间越多，我们从上面可以看到，虽然使用`gzip`的速度相当快，总时间花费不到1秒钟，但是压缩率最糟。如果使用`xz`的话，虽然压缩比最佳，不过竟然花了9秒钟的时间，这还仅是备份28MB 的`/etc`而已，如果备份的数据是很大容量的，那你真的要考量时间成本才行

至于加上`-p`这个选项的原因是==为了保存原本文件的权限与属性==，我们曾在`cp`指令时谈到权限与文件类型（如链接文件）对复制的不同影响。同样的，在备份重要的系统资料时，这些原本文件的权限需要做完整的备份比较好。此时，`-p`这个选项就派的上用场了。

##### 查看tar 文件的资料内容（可查看文件名），与备份文件名是否有根目录的意义

要查看由tar 所建立的打包文件内部的文件名非常简单，可以这样做：

```shell
#tar -jtv -f /root/etc.tar.bz2
...(前面省略)...
-rw-r--r-- root/root       131 2015-05-25 17:48 etc/locale.conf
-rw-r--r-- root/root        19 2015-05-04 17:56 etc/hostname
-rw-r--r-- root/root     12288 2015-05-04 17:59 etc/aliases.db
```

如果加上`-v`这个选项时，详细的文件权限/属性都会被列出来，如果只是想知道文件名而已，那么就将`-v`拿掉即可。从上面的信息我们可以发现一件很有趣的事情，那就是<u>每个文件名都没有根目录了</u>，这也是上个练习中出现的那个警告信息所告知的情况

那为什么要拿掉根目录呢？主要是为了安全。我们使用tar 备份的数据可能需要解压缩回来使用，在tar所记录的文件名（就是我们刚刚使用`tar -jtvf` 所查看到的文件名）那就是解压缩后的实际文件名。如果拿掉了根目录，假设你将备份资料在`/tmp`解开，那么解压缩的文件名就会变成`/tmp/etc/xxxx`。但如果没有拿掉根目录，解压缩后的文件名就会是绝对路径，亦即解压缩后的数据一定会被放到`/etc/xxx`去。如此一来，你的原本`/etc/`底下的数据，就会被备份数据所覆盖过去了

> 你会说：既然是备份资料，那么还原回来也没有什么问题吧？想象一个情况，你备份的数据是两年前的旧版 CentOS 6.x，你只是想了解一下过去的备份内容究竟有哪些数据而已，结果一解开该文件，却发现你目前新版的CentOS 7.x 底下的/etc 被旧版的备份文件覆盖了，所以，当然是拿掉根目录比较安全一些

如果你确定你就是要备份根目录到tar 文件中，可以使用`-P`：

```shell
范例：将文件名中的（根）目录也备份下来，并查看一下备份文件的内容文件名
#tar -jpPcv -f /root/etc.and.root.tar.bz2 /etc

#tar -jtf /root/etc.and.root.tar.bz2
/etc/locale.conf
/etc/hostname
/etc/aliases.db
#这次查询文件名不含 -v选项，所以仅有文件名而已，没有详细属性/权限等参数
```

如果加上`-P`选项，那么文件名内的根目录就会存在，不过，个人建议还是不要加上`-P`来备份，毕竟很多时候，我们备份是为了要未来追踪问题用的，倒不一定需要还原回原本的系统中，所以拿掉根目录后，备份数据的应用会比较有弹性，也比较安全

##### 基本名称： tarfile, tarball?

tar打包出来的文件有没有进行压缩所得到的文件称呼不同，如果仅是打包而已，就是`tar -cv -f file.tar`而已，这个文件我们成为tarfile。==如果还有进行压缩的支持，例如 `tar -jcv -f file.tar.bz2`时，我们就称呼为tarball==

此外，tar 除了可以将数据打包成为文件之外，还能够将文件打包到某些特别的设备中，比如，磁带机就是一个常见的例子。磁带机由于是一次性读取/写入的设备，因此我们不能够使用类似`cp`等指令来复制。如果想要将`/home`, `/root`, `/etc`备份到磁带机（`/dev/st0`)时，就可以使用：`tar -cv -f /dev/st0 /home /root /etc`。磁带机用在备份（尤其是企业应用）是很常见的工作。

##### 特殊应用： 利用管道命令与数据流

在tar的使用中，有一种方式最特殊，那就是通过标准输入输出的数据流重导向，以及管道命令的方式，将待处理的文件一边打包一边解压缩到目标目录中去。

```shell
# 将 /etc 整个目录一边打包一边在 /tmp 解开
#cd /tmp
#tar -cvf - /etc | tar -xvf -

# 这个动作有点像是 cp -r /etc /tmp 
# 要注意的地方在于输出文件变成 - 而输入文件也变成 -， 又有一个 | 存在
# 这分别代表 standard output， standard input 与管道命令
# 简单的想法中，你可以将 - 想成是在主存中的一个装饰（缓冲区）
```

在上面的例子中，我们想要将 /etc 底下的数据直接copy到目前所在的路径，也就是/tmp 下，但是又觉得 `cp -r`有点麻烦，那么就直接以这个打包的方式来打包，其中，指令里面的- 表示那个被打包的文件，由于我们不想要让中间文件存在，所以就以这个方式来进行复制的行为

##### 解压缩后的 SELinux 课题

如果因为某些缘故，你的系统必须要以备份的数据来回填到原本的系统中，那么得要特别注意复原后的系统的SELinux问题，尤其是在系统文件上。例如 /etc 下的文件。SELinux 的权限问题 <u>**可能会让你的系统无法存取某些配置文件内容，导致影响到系统的正常使用权**</u>

场景：使用tar 备份了/etc 的数据，然后尝试在另一部系统上复原回来。复原倒是没问题，但是复原完成后，无论如何就是无法正常的登录系统。明明使用单人维护模式去操作系统时，看起来一切正常，但就是无法顺利登录。

> 问题原因:

​		`/etc/shadow`这个密码文件的SELinux 类型在还原时被更改了，导致系统的登录程序无法顺利地存取它。

> 处理方式：

* 通过各种可行的救援方式登录系统，然后修改 `/etc/selinux/config`文件，将SELinux 改成 permissive 模式，重新开机后系统就正常了
* 在第一次复原系统后，不要立即重新开机，先用 `restorecon -Rv /etc` 自动修复一下SELinux的类型即可
* 通过各种可行的方式登录系统，建立 `/.autorelabel` 文件，重新开机后系统会自动修复SELinux的类型，并且又会再次重新开机，之后就正常了。

鸟哥个人比较偏好第2个方法，不过忘了该步骤就重新开机，那鸟哥比较偏向使用第3个方案来处理，这样就能够解决复原后的SELinux 问题。



